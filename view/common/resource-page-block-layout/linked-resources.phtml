<?php
$related_info_terms = $this->themeSetting('related_terms');//they wont create new linked resources
$orderEventsPropTerm = $this->themeSetting('order_events');
//les classes sont regroupées par catégories puisque omeka-s ne propose pas de gérer l'héritage de classes
//j'ai choisi de réunir par classes plus que par propriété car par exemple la classe "acquisition" pourra être montré sur une fiche E22HMO et une fiche E21Person (donc appelé par des props différentes); 
$events_mapping = $this->themeSetting('events_mapping');
$eventTypes = explode("\n", $events_mapping);
foreach ($eventTypes as $eventType){
    $spltd  = preg_split("/\s*>\s*/", $eventType);
    $eventClassLabel = trim($spltd[0]);
    $eventClasses = preg_split("/[,;]/", $spltd[1]);
    $displayedEventsMapping[$eventClassLabel] = array_map('trim', $eventClasses);
};





// $displayedEventsMapping = array(
//     'Conception' => array('crm:E65_Creation'),
//     'Production' => array('crm:E12_Production',),
//     'Modification' => array('crm:E11_Modification', 'crm:E79_Part_Addition', 'crm:E80_Part_Removal'),
//     'Acquisition' => array('crm:E8_Acquisition', 'crm:E96_Purchase', 'crm:E10_Transfer_of_Custody'),
//     'Destruction' => array('crm:E6_Destruction', 'crm:E64_End_of_Existence', 'crm:E81_Transformation'),
// );
//mapping of class id with categories
$eventClassId2categ = array();
foreach($displayedEventsMapping as $eventCategory=>$eventClassTermArray){
    foreach($eventClassTermArray as $eventClassTerm){
        $eventClassId = $this->api()->searchOne('resource_classes', ['term'=>$eventClassTerm])->getContent()->id();
        $eventClassId2categ[$eventClassId] = $eventCategory;
    }
};

//because they are allready show in the box 'associated elemtns' they won't appear in the linked resources
$skippedPropsList = preg_split("/[;,]\s?/", $related_info_terms);
$skippedPropsIdList = array();
foreach($skippedPropsList as $skipedPropTerm){
    $skippedPropId = $this->api()->searchOne('properties', ['term'=>$skipedPropTerm])->getContent()->id();
    $skippedPropsIdList[] = $skippedPropId;
};

$foundEvents = array();
$otherLinkedItems = array();


//this should be split into 2: find events and categorize events
//this finds the linked resources and order them by date (time_span)
$i=0;
$j=0;
$maxTerm = 20;
$max_itemPerTerm = 8;
foreach ($resource->subjectValues() as $index => $subjectValues) {
    if(++$i > $maxTerm) break;//max terms analyzed
    $termID = explode('-',$index)[0];
    if (!in_array($termID, $skippedPropsIdList)){//the prop is not among the forbidden ones
        foreach ($subjectValues as $subjectValue) {
            if(++$j > $max_itemPerTerm) break;//max item analyzed per term
            // $this->logger()->info(json_encode($subjectValue['val']->resource()));
            $subjectResource = $subjectValue['val']->resource();
            if ($subjectResource->getControllerName($subjectResource) === 'item'){//if the linked item is not a media (through RightsHolder property)
                $subjectResourceClassId = $subjectResource->resourceClass()->id();
                $datelit = $subjectResource->value($orderEventsPropTerm, ['literal']);
                preg_match('/\d\d\d\d?/', $datelit, $date);
                // echo(print_r($date, TRUE));
                $dateindex = empty($date) ? 0 : 100*$date[0] ;// ex: 194400 for 1944
                if (in_array($subjectResourceClassId, array_keys($eventClassId2categ))){
                    //manage case with no date. Objective: basic order by order of the displayedEventsMapping : conception then production then modification, then etc.
                    
                    while (key_exists($dateindex, $foundEvents)) {++$dateindex; };//if key allready in use (same date); then go to next index (194401 for example)
                    $foundEvents[$dateindex] = $subjectResource;
                } else {
                    while (key_exists($dateindex, $otherLinkedItems)) {++$dateindex; };
                    $otherLinkedItems[$dateindex] = $subjectResource;
                };
            }
            
        };
    }  
};
ksort($foundEvents);
ksort($otherLinkedItems);




function writeEvent($event, $eventClassId2categ=null, $viewFile=null) {
//    echo json_encode($eventClassId2categ);
    $eventClass = $event->resourceClass();
    if (!isset($eventClass)){
        //$logger->info("no class found for this item (event): {$event->id()}");//TODO fix "Error: Using $this when not in object context"
        //TODO ecrire quelque chose dans la vue pour qu'on s'enn rende compte
        return;
    }
    $eventClassId = $eventClass->id();
    $eventURL = $event->url();
    $displayString = (isset($eventClassId2categ) && key_exists($eventClassId, $eventClassId2categ)) ? $eventClassId2categ[$eventClassId] : $event->resourceClass()->label();
    ?>
    <dl id = <?php echo ("linkedResource-" . $event->id())?> class="bloco linkedBloco">
        <h3><?php echo $displayString?></h3>
        <?php
        echo $viewFile ? $event->displayValues(array('viewName' => $viewFile,)) : $event->displayValues();
        ?>
        <div class="center"><a href=<?php echo $eventURL?> >plus d'info sur cette resource</a></div>
    </dl>
    <?php
};
?>


<div class="columnTitle">
    ↓ Évenements du cycle de vie de l'item ↓
</div>

<!-- subject values printing -->
<?php if (!$foundEvents): ?>
    <dl id = "noEventWarning" class="bloco linkedBloco" >
        <div class="center">Aucun évenement trouvé</div>
    </dl>
<?php else: 
    foreach ($foundEvents as $event) {
        writeEvent($event, $eventClassId2categ, 'common/resource-values_event-in-item');
    };        
endif; ?>


<?php if ($otherLinkedItems): ?>
    <div class="columnTitle">
    ↓ Autres éléments associés trouvés ↓
    </div>
    <?php 
    foreach ($otherLinkedItems as $item) {
        writeEvent($item, null, $viewFile);
    };
    ?>
<?php endif; ?>
